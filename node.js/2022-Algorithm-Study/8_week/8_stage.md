# 8주차(05.07~05.13)

## Stage 8 - 기본 수학 2

### 1978번 소수 찾기

#### 전략

- 소수인지 체크하는 함수를 만들어서 true로 반환될 경우 `count` 값을 하나씩 늘린다.
  - 1은 숫자가 아니므로 제외하고, 숫자를 2부터 `number` 값까지 나눠서 하나라도 나누어 떨어지면 false 값을 반환한다.
  - 그게 아니라면, 그 숫자는 소수이므로 true를 반환한다.

#### 실수

- 처음에는 2와 3의 배수만 아니라면 소수가 아닌 줄 알아서 문제를 틀렸었다. 집중하자!!

### 2581번 소수

#### 전략

- 소수인지 체크하는 함수를 만들어서 true로 반환될 경우 `count` 값을 하나씩 늘린다.
  - 1은 숫자가 아니므로 제외하고, 숫자를 2부터 `number` 값까지 나눠서 하나라도 나누어 떨어지면 false 값을 반환한다.
  - 그게 아니라면, 그 숫자는 소수이므로 true를 반환한다.
- 만약 소수가 맞다면, `sum` 변수에 값을 더하고 `array` 배열에 값을 추가시킨다.
- 범위값의 모든 수를 체크하고, 합과 최솟값 출력 (배열의 length가 0이면 `-1` 출력)

#### 실수

- 처음에 최솟값을 구하려고 `Math.min()`을 썼는데, 생각해보니 안써도 됐다.

### 11653번 소인수분해

#### 전략

- 입력값(input)을 `2~입력값`까지의 범위로 1이 될 때까지 반복문을 통해서 나눈다.
- 값이 안 나누어 떨어진다면 값을 하나 늘리고, 값이 나누어진다면 입력값(input)을 나눈 뒤에 나누는 값(number)을 `2`로 초기화 시킨다.

### 1929번 소수 구하기

![](https://blog.kakaocdn.net/dn/b69C2I/btrj9l5evAu/Nl7ux67P1VAD4mAOiM0sKK/img.gif)

#### 전략

- 이 문제는 `에라토스테네스의 체`를 이용하여 푸는 문제이다. `에라토스테네스의 체`란 2부터 n까지의 자신을 제외한 배수를 제거하다 보면 소수만 남는다는 원리이다.
- 어떤 수의 배수가 되는 수는 (1과 자신의 수)가 아닌 다른 수로 나누어 떨어지기에 소수가 될 수 없다.
- 이때, 루트n까지만 판별해도 결과는 똑같다. 루트25(5)는 5의 배수로 쳐 소수가 아닌 수로 분류된다.

#### 실수

- 평소처럼 소수를 구하다가 시간 초과로 혼쭐 났다. 어떻게 풀지 검색해보다가 `에라토스테네스의 체`라는 개념을 배웠다. 조금 생소하긴한데 익숙해지도록 노력해야겠다.

### 4948번 베르트랑 공준

#### 전략

- 소수를 구하는 함수를 만들고 `N~N*2` 범위를 확인해서 소수일 때 `count` 값을 하나씩 올린다.

#### 개선된 소수 판별 알고리즘

시간을 단축시키기 위해서 개선된 소수 판별 알고리즘을 적용했다. 2 이상의 임의의 자연수 N의 약수들은, 가운데 약수를 기준으로 곱셈 연산에 대해 대칭을 이룬다. 예를 들어, 16의 약수는 1, 2, 4, 8, 16이고 이때 2 x 8 = 16은 8 x 2 = 16과 대칭이다. 따라서 자연수의 모든 약수를 찾을 때 가운데 약수(제곱근)까지만 확인하면 된다.

#### 에라토스테네스의 체

에라토스테네스의 체 알고리즘은 다수의 자연수에 대하여 소수 여부를 판별할 때 사용하는 대표적인 알고리즘이다. 에라토스테네스의 체는 N보다 작거나 같은 모든 소수를 찾을 때 사용할 수 있어 이 문제를 풀기에 적합하다. 에라토스테네스의 체 알고리즘의 구체적인 동작 과정은 다음과 같다.

1. 2부터 N까지의 모든 자연수를 나열한다.
2. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다.
3. 남은 수 중에서 i의 배수를 모두 제거한다. (i는 제거하지 않는다.)
4. 더 이상 반복할 수 없을 때까지 2번과 3번의 과정을 반복한다.

이 문제는 M이상 N이하의 수들의 소수 여부를 출력하면 되기 때문에, 1번에서 2부터가 아니라 M부터 소수인지 판별하면 된다. 그리고 3번 과정에 위에서 언급한 개선된 소수 판별 알고리즘을 적용하면 시간복잡도가 O(N^(3/2))가 되어 시간 내에 문제를 풀 수 있다.

[정리 잘 된 블로그](https://gywlsp.github.io/boj/1929/)

#### 실수

- 입력값의 마지막에 `0`이 들어가는 부분을 if문을 통해 제외시키지 않고 `input.length-1`로 무식하게 처리해줘서 틀렸다.
