# 8주차(05.07~05.13)

## Stage 8 - 기본 수학 2

### 1978번 소수 찾기

#### 전략

- 소수인지 체크하는 함수를 만들어서 true로 반환될 경우 `count` 값을 하나씩 늘린다.
  - 1은 숫자가 아니므로 제외하고, 숫자를 2부터 `number` 값까지 나눠서 하나라도 나누어 떨어지면 false 값을 반환한다.
  - 그게 아니라면, 그 숫자는 소수이므로 true를 반환한다.

#### 실수

- 처음에는 2와 3의 배수만 아니라면 소수가 아닌 줄 알아서 문제를 틀렸었다. 집중하자!!

### 2581번 소수

#### 전략

- 소수인지 체크하는 함수를 만들어서 true로 반환될 경우 `count` 값을 하나씩 늘린다.
  - 1은 숫자가 아니므로 제외하고, 숫자를 2부터 `number` 값까지 나눠서 하나라도 나누어 떨어지면 false 값을 반환한다.
  - 그게 아니라면, 그 숫자는 소수이므로 true를 반환한다.
- 만약 소수가 맞다면, `sum` 변수에 값을 더하고 `array` 배열에 값을 추가시킨다.
- 범위값의 모든 수를 체크하고, 합과 최솟값 출력 (배열의 length가 0이면 `-1` 출력)

#### 실수

- 처음에 최솟값을 구하려고 `Math.min()`을 썼는데, 생각해보니 안써도 됐다.

### 11653번 소인수분해

#### 전략

- 입력값(input)을 `2~입력값`까지의 범위로 1이 될 때까지 반복문을 통해서 나눈다.
- 값이 안 나누어 떨어진다면 값을 하나 늘리고, 값이 나누어진다면 입력값(input)을 나눈 뒤에 나누는 값(number)을 `2`로 초기화 시킨다.

### 1929번 소수 구하기

![](https://blog.kakaocdn.net/dn/b69C2I/btrj9l5evAu/Nl7ux67P1VAD4mAOiM0sKK/img.gif)

#### 전략

- 이 문제는 `에라토스테네스의 체`를 이용하여 푸는 문제이다. `에라토스테네스의 체`란 2부터 n까지의 자신을 제외한 배수를 제거하다 보면 소수만 남는다는 원리이다.
- 어떤 수의 배수가 되는 수는 (1과 자신의 수)가 아닌 다른 수로 나누어 떨어지기에 소수가 될 수 없다.
- 이때, 루트n까지만 판별해도 결과는 똑같다. 루트25(5)는 5의 배수로 쳐 소수가 아닌 수로 분류된다.

#### 실수

- 평소처럼 소수를 구하다가 시간 초과로 혼쭐 났다. 어떻게 풀지 검색해보다가 `에라토스테네스의 체`라는 개념을 배웠다. 조금 생소하긴한데 익숙해지도록 노력해야겠다.

### 4948번 베르트랑 공준

#### 전략

- 소수를 구하는 함수를 만들고 `N~N*2` 범위를 확인해서 소수일 때 `count` 값을 하나씩 올린다.

#### 개선된 소수 판별 알고리즘

시간을 단축시키기 위해서 개선된 소수 판별 알고리즘을 적용했다. 2 이상의 임의의 자연수 N의 약수들은, 가운데 약수를 기준으로 곱셈 연산에 대해 대칭을 이룬다. 예를 들어, 16의 약수는 1, 2, 4, 8, 16이고 이때 2 x 8 = 16은 8 x 2 = 16과 대칭이다. 따라서 자연수의 모든 약수를 찾을 때 가운데 약수(제곱근)까지만 확인하면 된다.

#### 에라토스테네스의 체

에라토스테네스의 체 알고리즘은 다수의 자연수에 대하여 소수 여부를 판별할 때 사용하는 대표적인 알고리즘이다. 에라토스테네스의 체는 N보다 작거나 같은 모든 소수를 찾을 때 사용할 수 있어 이 문제를 풀기에 적합하다. 에라토스테네스의 체 알고리즘의 구체적인 동작 과정은 다음과 같다.

1. 2부터 N까지의 모든 자연수를 나열한다.
2. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다.
3. 남은 수 중에서 i의 배수를 모두 제거한다. (i는 제거하지 않는다.)
4. 더 이상 반복할 수 없을 때까지 2번과 3번의 과정을 반복한다.

이 문제는 M이상 N이하의 수들의 소수 여부를 출력하면 되기 때문에, 1번에서 2부터가 아니라 M부터 소수인지 판별하면 된다. 그리고 3번 과정에 위에서 언급한 개선된 소수 판별 알고리즘을 적용하면 시간복잡도가 O(N^(3/2))가 되어 시간 내에 문제를 풀 수 있다.

[정리 잘 된 블로그](https://gywlsp.github.io/boj/1929/)

#### 실수

- 입력값의 마지막에 `0`이 들어가는 부분을 if문을 통해 제외시키지 않고 `input.length-1`로 무식하게 처리해줘서 틀렸다.

### 9020번 골드바흐의 추측

#### 전략

1. 입력값 중에서 최댓값을 구해서 최댓값의 소수들을 `numbers` 배열에 저장해둔다. (에라토스테네스의 체 알고리즘)
2. A와 B 변수에 입력값의 반(half)값을 넣어서 하나는 각각 1을 더하고 빼준다.
3. 만약 그 두 값이 소수라면 값을 출력한다. 아니면 2번부터 반복한다.

#### 실수

- 처음에는 최댓값의 소수들을 구한 후에 배열의 대칭성을 이용해서 풀려고 했으나, 백준에서 틀렸다고 나와서 다른 방법을 시도했다.
- 내 방법이 맞다고 고집하지말고, 너무 많이 고민한다 싶으면 다른 사람의 알고리즘을 적극 수용하자.

### 10872번 팩토리얼

#### 전략

- 재귀함수란 어떤 범위에 있는 모든 정수를 곱하는 것이다.
- `n-1`을 곱하는 것이 반복되므로 재귀함수를 이용하여 문제를 풀면 된다.

### 10870번 피보나치 수 5

#### 전략

- 피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.
- 이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.
- `number`가 0일 때는 `0`을 return 하고, 1일 때는 `1`을 return 하고, 그 외에 수는 `getFibonachi(number - 2) + getFibonachi(number - 1)` 로 return 해준다.

### 17478번 재귀함수가 뭔가요?

#### 전략

- 모든 질문과 답변을 변수와 배열을 이용해서 저장을 했다.
- 첫 질문(`어느 한 컴퓨터공학과 학생이 유명한 교수님을 찾아가 물었다.`)은 단독적으로 나오는 멘트기 때문에 재귀함수에 포함시키지 않고 바로 출력을 시킨다.
- 그리고 `____` 공백문자를 기준으로 출력 방법을 나눈다.
- 제일 먼저 `재귀함수가 뭔가요? 재귀함수는 자기 자신을 호출하는 함수라네 라고 답변하였지.` 를 출력시킨다.
- 그리고 number의 값을 하나씩 줄여나가면서 `재귀함수가 뭔가요?~잘 들어보게...~라고 답변하였지.` 를 출력시킨다.

#### 어려웠던 점

- 어떻게 하면 코드를 깔끔하게 짤지 고민을 많이 했다. 처음에는 무지성으로 문자열을 바로 출력시키려다가 그렇데 풀면 안되겠다 싶어서 바로 변수와 배열에 멘트를 저장해서 조금 더 코드 유지보수가 쉽도록 만들었다.

### 2447번 별 찍기 - 10

#### 전략

- 이 문제는 공백이 들어가는 칸의 패턴을 잘 파악해서 푸는 문제이다.
- 먼저, 입력값이 3일 때를 생각해보면 `(1,1)`이 공백을 출력해야 하는 위치인 것을 알 수 있는데, 이는 i, j%3의 값이 1인 곳을 찾음으로서 해결할 수 있다. 이 경우가 재귀에서 처리하는 최소범위의 값이다.
- 9로 넘어갈 경우, 우리가 공백으로 처리한 부분 이외에 추가로 공백을 칠해줘야 하는 부분이 나오는데 다음과 같다.

```
(3,3) (3,4) (3,5)

(4,3) (4,4) (4,5)

(5,4) (5,4) (5,5)
```

- 여기서 i와 j의 범위는 모두 `3^1 <= i,j < 3^1 + 3^1` 이다.
- 이 부분을 처리해주기 위해 3으로 나눈 값의 목만을 취해서 재귀로 호출한다. 그러면, 모두 공백(`n%3===1`)일 경우에 해당해서 공백이 출력된다.

#### 어려웠던 점

- 빈 칸의 규칙을 찾으려고 애썼지만, 결국 오랜 시간 고민해도 찾아내지 못했다. 정말 재귀함수 문제는 많이 풀어봐야 될 것 같다. 어떻게 이런 규칙을 찾을 수 있는지 ㅠㅠ..
