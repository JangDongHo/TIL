# 인터넷은 어떻게 동작하는가?
> 해당 문서는 [인터넷은 어떻게 동작하는가?](https://developer.mozilla.org/ko/docs/Learn/Common_questions/How_does_the_Internet_work) 를 참조했습니다.
## 요약
`인터넷` - 웹의 핵심적인 기술! 컴퓨터들이 서로 통신 가능한 거대한 네트워크

인터넷의 역사 
- 1960년대 미육군에서 기금한 연구프로젝트에서 시작
- 1980년대 많은 국립 대학과 비공개 기업의 지원으로 공공의 기반으로 변화
- 인터넷을 지원하는 다양한 기술은 시간이 자남에 따라 진화, But 작동 방식은 그대로!

**인터넷은 모든 컴퓨터를 연결하고 어떤 일이 있어도 연결 상태를 유지할 수 있는 방법을 찾는 방법이다.**

## 활동적으로 배우기
들어가기에 앞서 도움이 된 영상 : [링크](https://www.youtube.com/watch?v=Pwf-YG--Zsg)

## 깊게 들어가기
### 단순한 네트워크
- 두 개의 컴퓨터가 통신이 필요할 때
    - 다른 컴퓨터와 물리적으로(`이더넷` 케이블) 또는 무선(WiFi or 블루투스)으로 연결되어야함.
- 그 이상이라면?
    - (N*(N-1))/2 만큼의 케이블이 필요함! 즉 매우 복잡해진다.
    - 해결 방안
        - 네트워크의 각 컴퓨터는 `라우터` 라고 하는 특수한 소형 컴퓨터에 연결되는데, 라우터가 중앙에서 철도역의 신호원처럼 메시지를 보내주는 역할을 수행해주면 케이블수를 확연히 줄일 수 있다!
        - 라우터 역할: 철도역의 신호원처럼 주어진 컴퓨터에서 보낸 메시지가 올바른 대상 컴퓨터에 도착하는지 확인!

## 네트워크 속의 네트워크
- 만약, 수백, 수천, 수십억 대의 컴퓨터를 연결하려면?
    - 컴퓨터를 라우터에 연결하고, 라우터에서 라우터로 무한히 확장하면 됨!
    - But, 내 집(부산)에서 서울까지 케이블로 연결이 가능한가? No!
        - 해결 방안
            - 이미 집에 연결되어 있는 '전화 케이블' 사용한다.
            - Why? 전화기 기반의 시설은 이미 모든 세계와 연결되어 있으므로 이보다 완벽한 배선이 없다.
        - 우리의 네트워크를 전화 시설과 연결하기 위해선 `모뎀` 이라는 특수장비 필요!
            - 모뎀의 역할: 네트워크의 정보를 전화시설에서 처리할 수 있는 정보로 바꿈! (역도 성립)
        - 우리의 네트워크가 전화 시설에 연결 -> 도달하려는 네트워크로 메시지 전송
            - 이때, 메시지 전송은 `인터넷 서비스 제공업체(Internet Service Provider, ISP)`에서 담당함.
            - ISP: 다른 ISP의 라우터에도 액세스 할 수 있는 회사 (ex. LG U+, SKT, KT 등)

## 컴퓨터 찾기
- 컴퓨터에서 메시지를 보내려면 메시지를 받을 특정 컴퓨터를 지정해야한다.
    - So, 네트워크에 연결된 모든 컴퓨터에는 'IP주소'라는 고유한 주소가 존재
    - `IP주소`: 점으로 구분된 네 개의 숫자로 구성된 주소 (ex. 192.168.2.10.)
    - But, 인간은 IP주소를 기억하기 힘듦 -> 인간이 기억하기 쉬운 `도메인 이름` 사용 (ex. google.com)

## 인터넷과 웹
- 웹 브라우저에서 웹을 탐색할 때 일반적으로 도메인 이름을 사용하여 웹사이트 접속
    - 오! 그럼 인터넷 = 웹? No~
    - 인터넷 - 수십 억 대의 컴퓨터를 모두 연결하는 기술 인프라
    - 웹 = 그 인프라 기반 위에 구축된 서비스
    - 이러한 컴퓨터들 중 일부는 '웹 서버' -> 웹 브라우저가 이해할 수 있는 서비스 제공

# HTTP는 무엇일까요?
> 해당 문서는 [What is HTTP?](https://velog.io/@surim014/HTTP%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80) 를 참조했습니다.

## HTTP (HyperText Transfer Protocol)
- 텍스트 기반의 통신 규약
- **인터넷에서 데이터를 주고받을 수 있는 프로토콜**이다.
- 이렇게 규약을 정해두었기 때문에 모든 프로그램이 이 규약에 맞춰 개발해서 서로 정보를 교환할 수 있게 되었다.

### HTTP 동작
- `클라이언트`(사용자)가 브라우저를 통해서 어떠한 서비스를 url을 통하거나 다른 것을 통해서 `요청`(request)을 하면 서버에서는 해당 요청사항에 맞는 결과를 찾아서 사용자에게 `응답`(response)하는 형태로 동작한다.
    > 요청 : client -> server

    > 응답 : server -> client

- HTML 문서만이 HTTP 통신을 위한 유일한 정보 문서는 아님.
- Plain Text로 부터 JSON 데이터 및 XML과 같은 형태의 정보도 주고 받을 수 있다.
- 보통은 클라이언트가 어떤 정보를 HTML 형태로 받고 싶은지, JSON 형태로 받고 싶은지 명시해주는 경우가 많음.

### HTTP 특징
- HTTP 메시지는 HTTP 서버와 HTTP 클라이언트에 의해 해석이 된다.
- TCP/IP를 이용하는 응용 프로토콜이다.
  (컴퓨터와 컴퓨터간에 데이터를 전송 할 수 있도록 하는 장치로 인터넷이라는 거대한 통신망을 통해 원하는 정보(데이터)를 주고 받는 기능을 이용하는 응용 프로토콜)
- HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜 (이러한 단점을 해결하기 위해 Cookie와 Session이 등장)
- HTTP는 연결을 유지하지 않는 프로토콜이기 때문에 요청/응답 방식으로 동작

### 예시로 알아보는 HTTP
> 서버 : 어떠한 자료에 대한 접근을 관리하는 네트워크 상의 시스템

> 클라이언트 : 그 자료에 접근할 수 있는 프로그램 (ex. 웹 브라우저, 핸드폰 어플리케이션 등...)

1) 클라이언트 프로그램에서 사용자가 회원가입 시도
2) 서버로 회원정보 전송
3) 서버는 회원정보 저장

**이 과정에서 클라이언트와 서버 간의 교류가 HTTP라는 규약을 이용하여 발생**

## Request (요청)
- 요청 : **클라이언트가 서버에게 연락하는 것**
- 요청을 보낼때는 요청에 대한 정보를 담아 서버로 전송

### Request Method (요청의 종류)
- GET : 자료를 `요청`할 때 사용
- POST : 자료의 `생성`을 요청할 때 사용
- PUT : 자료의 `수정`을 요청할 때 사용
- DELETE : 자료의 `삭제`를 요청할 때 사용

### Request HTTP 메시지 예시
~~~
GET https://velog.io/@surim014 HTTP/1.1								// 시작줄
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...			  // 헤더
Upgrade-Insecure-Requests: 1

~~~
1. 시작줄 (첫 줄)
- 첫 줄은 시작줄로 **메서드 구조 버전**으로 구성
    - GET : HTTP Method
    - https://velog.io/@surim04 : 사이트 주소
    - HTTP/1.1 : HTTP 버전
2. 헤더 (두 번째 줄부터)
- 두번째 줄부터는 헤더이며 **요청에 대한 정보**를 담고 있다. User-Agent, Upgrade-Insecure-Requests 등등이 헤더에 해딩되며 헤더의 종류는 매우 많다.
3. 본문 (헤더에서 한 줄 띄고)
- 본문은 **요청을 할 때 함께 보낼 데이터를 담는 부분**이다. 현재 예시에는 단순히 주소로만 요청을 보내고 있고 따로 데이터를 담아 보내지 않기 때문에 본문이 비어있다.

## Response (응답)
**서버가 요청에 대한 답변을 클라이언트에게 보내는 것**을 응답이라고 한다.

### Status Code (상태 코드)
- 상태 코드에는 굉장히 많은 종류가 존재. 모두 숫자 세 자리로 이루어져있으며, 아래와 같이 크게 다섯 부류로 나눔.
    - **1XX(조건부 응답)** : 요청을 받았으며 작업을 계속한다.
    - **2XX(성공)** : 클라이언트가 요청한 동작을 수신하여 이해했고 승낙했으며 성공적으로 처리했음을 가리킨다.
    - **3XX(리다이렉션 완료)** : 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다.
    - **4XX(요청 오류)** : 클라이언트에 오류가 있음을 나타낸다.
    - **5XX(서버 오류)** : 서버가 유효한 요청을 명백하게 수행하지 못했음을 나타낸다.

### Response HTTP 메시지 예시
~~~
HTTP/1.1 200 OK														// 시작줄
Connection: keep-alive												 // 헤더
Content-Encoding: gzip												 
Content-Length: 35653
Content-Type: text/html;

<!DOCTYPE html><html lang="ko" data-reactroot=""><head><title...
~~~
1. 시작줄 (첫 줄)
- 첫 줄은 **버전 상태코드 상태메시지**로 구성. 200은 성공적인 요청이었다는 뜻.

2. 헤더 (두 번째 줄부터)
- 두 번째 줄부터는 헤더로 **응답에 대한 정보를 담고 있다**.

3. 본문 (헤더 뒤부터)
- 응답에는 대부분의 경우 본문이 있다. 보통 데이터를 요청하고 응답 메시지에는 **요청한 데이터를 담아서 보내주기 때문이다. 응답 메시지에 HTML이 담겨 있는 이 HTML을 받아 브라우저가 화면에 렌더링한다.**
